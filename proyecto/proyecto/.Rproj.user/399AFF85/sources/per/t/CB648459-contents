###############
## Script 26 ##
###############

## Earthquakes
Sismos = rio::import("earthquakes.xlsx")
n <- dim(Sismos)[1]

## Plot
par(mfrow = c(1,1), bty = "n", las = 1)
plot(Count ~ Date, data = Sismos, type = "s", xaxt = "n")
axis(1, quantile(Sismos$Date), as.Date(quantile(Sismos$Date)))

## ACF's
X <- Sismos$Count
par(mfrow = c(1,2), bty = "n", las = 1)
acf(X, lag.max = 10, ylim = c(-1,1), xlim = c(0,10), main = "")
pacf(X, lag.max = 10, ylim = c(-1,1), xlim = c(0,10), main = "")

## Descripción
mean(Sismos$Count)
var(Sismos$Count)

## auto.arima
fit = forecast::auto.arima(y = ts(Sismos$Count))
summary(fit)
plot(fit)

## Time Plot vs Fitted Values
par(mfrow = c(1,1), bty = "n", las = 1)
plot(Count ~ Date, data = Sismos, type = "s", xaxt = "n")
axis(1, quantile(Sismos$Date), as.Date(quantile(Sismos$Date)))
lines(fit$fitted ~ Sismos$Date, col = "red", lwd = 2, type = "s")


## Diagnostico 
source("TS.diag.R")
TS.diag(fit$res)

###################################
## Modelamiento INAR vía Whittle ##
###################################

## Modelo: Y[t] = a1 o Y[t-1] + ... + ap o Y[t-p] + b * e[t], {e[t]}~Poisson(lambda)
## Esta extensión permite media y varianza distinta en los datos, 
## el clásico INAR no tiene esa restricción en su error

## Periodograma
LSTS::periodogram(Sismos$Count)

fdensity.inar = function(ar = numeric(), lambda = 1, eta = 1, mu = NULL, omega = NULL){
p = length(ar)
phi = c(1,-ar)
if(is.null(omega)){
	omega = seq(0,pi,0.01)
	}
n = length(omega)
aux = c()
for(k in 1:n){
aux[k]=1/(sum((phi * exp(-1i*omega[k]*c(0:p))))*sum((phi * exp(+1i*omega[k]*c(0:p)))))
}
mu = eta * lambda/(1-sum(ar))
aux = (eta^2 * lambda + mu * sum(ar*(1-ar)))*Re(aux)/(2*pi)
aux
}

whittle.loglik = function(x, serie, p = 1){
Y = serie
n = length(Y)
ar  = x[1:p]
eta = x[p+1]
lambda = x[p+2]
aux = LSTS::periodogram(Y, plot = F)
I = aux$periodogram
omega = aux$lambda
f = fdensity.inar(ar = ar, lambda = lambda, eta = eta, mu = NULL, omega = omega)
aux = 0.5*(sum(log(f)) + sum(I/f))/n
aux
}

fit2 <- nlminb(start = c(0.5, 2, 5), objective = whittle.loglik, serie = X, p = 1, lower = c(0.0001,0.0001, 0.0001), upper = c(0.99999, Inf, Inf))$par

Y.hat = c()
Y = Sismos$Count
alpha  = fit2[1]
eta    = fit2[2]
lambda = fit2[3]
mu = eta * lambda/(1-sum(alpha))
for(t in 2:n){
	Y.hat[t]  = alpha*Y[t-1]+eta*lambda
}

## Time Plot vs Fitted Values
par(mfrow = c(1,1), bty = "n", las = 1)
plot(Count ~ Date, data = Sismos, type = "s", xaxt = "n")
axis(1, quantile(Sismos$Date), as.Date(quantile(Sismos$Date)))
lines(Y.hat ~ Sismos$Date, col = "red", lwd = 2, type = "s")

Z <- Y - Y.hat
LSTS::ts.diag(Z)
